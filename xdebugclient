#!/usr/bin/php
<?php

class XDebugClient {
    protected $socket;
    protected $transaction_id = 1;
    protected $status = 'starting';
    protected $current_file = '';
    protected $current_line = '';
    
    function __construct($uri) {
    }

    function run() {
        // We'll handle XML errors ourselves, to avoid it spewing
        // warnings all over the place.
        libxml_use_internal_errors(true);
        // @todo error handling.
        $server = stream_socket_server("tcp://0.0.0.0:9000", $errno, $errstr);

        $this->puts("Waiting for connection...");
        $this->socket = stream_socket_accept($server);
        // $this->socket->selectRead(60);
        $packet = fread($this->socket, 4096);
        // Strip null byte an verify.
        $res = $this->parseResponse(substr($packet, 0, -1));
        if (!$res) {
            $this->puts('Error parsing init packet, exiting.');
            $this->exit(1);
        }
        if ($res['protocol_version'] != '1.0') {
            $this->echo('Unsupported protocol version.');
            $this->exit(1);
        }
        if ($res->engine) {
            $this->puts('> ' . (string) $res->engine . ' (' . $res->engine['version'] . ')');
        }
        if ($res->url) {
            $this->puts('> ' . (string) $res->url);
        }
        if ($res->author) {
            $this->puts('> by ' . (string) $res->author);
        }
        if ($res->copyright) {
            $this->puts('> ' . (string) $res->copyright);
        }
        if ($res['fileuri']) {
            $this->current_file = $res['fileuri'];
        }
        $this->puts("Connected.");

        // We have no further need for the server socket.
        fclose($server);

        stream_set_blocking(STDIN, 0);
        stream_set_blocking($this->socket, 0);
        $this->prompt();

        $exit = false;
        $input_buffer = "";
        do {
            $read = array(STDIN, $this->socket);
            $write = array();
            $except = array();
            $result = stream_select($read, $write, $except, null);
            if ($result === false) {
                $this->puts("Error using select.");
                $this->quit(1);
            };

            if (in_array($this->socket, $read)) {
                $packet = fread($this->socket, 4096);
                if ($packet != '') {
                    $res = $this->parseResponse($packet);
                    $this->handleResponse($res);
                    $this->prompt();
                }
            }
            if (($input = stream_get_line(STDIN, 1)) or $input_buffer) {
                if ($input) {
                    $input_buffer .= $input;
                }
                $t = explode("\n", $input_buffer, 2);
                if (sizeof($t) > 1) {
                    list($cmd, $rest) = $t;
                    $input_buffer = $rest;
                    if (preg_match('/^q(uit)?/', $cmd)) {
                        fwrite($this->socket, 'detach' . "\0");
                        $this->puts("Exiting.");
                        $this->quit();
                    }
                    $cmd = $this->handleShortCommands($cmd);
                    // Add in a transaction id.
                    $cmd = explode(' ', $cmd);
                    $cmd[0] .= ' -i ' . ($this->transaction_id++);
                    fwrite($this->socket, implode(' ', $cmd) . "\0");
                }
            }
        } while (!$exit);
    }

    function parseResponse($packet) {
        // Every packet starts with a lenght of the following XML data.
        if (!preg_match('/^([0-9]+)(.*)$/s', $packet, $matches)) {
            $this->puts("Malformed server packet:");
            $this->puts($packet);
            $this->quit(1);
        }
        // No PHP XML parsers seems to like XDebugs <?xml version="1.0"
        // encoding="iso-8859-1"? > header, oddly enough. So we strip it.
        $xml = $matches[2];
        $lines = explode("\n", $matches[2]);
        array_shift($lines);
        $xml = implode("\n", $lines);
        try {
            $res = new SimpleXMLElement($xml);
        }
        catch (Exception $e) {
            $this->puts('Exception: ' . $e->getMessage());
            $res = null;
        }
        if ($errors = libxml_get_errors()) {
            $this->puts('Errors parsing XML response.');
            foreach ($errors as $error) {
                $this->puts(print_r($error, true));
            }
            $this->puts("Raw XML data:");
            $this->puts($xml);
        }
        return $res;
    }

    function handleShortCommands($cmd) {
        // Empty line, or ones just containing whitespace is
        // interpreted as step_into.
        if (trim($cmd) == "") {
            return "step_into";
        }
        if (preg_match('/^([snf])( .*)?$/', $cmd, $matches)) {
            switch ($matches[1]) {
            case 's':
                $cmd = 'step_into';
                break;
            case 'n':
                $cmd = 'step_over';
                break;
            case 'f':
                $cmd = 'step_out';
                break;
            }
            return $cmd . (isset($matches[2]) ? $matches[2] : '');
        }
        return $cmd;
    }

    function handleResponse($res) {
        $root_element = $res->getName();
        if ($root_element == 'stream') {
            $this->puts("Got some data. Implement this.");
        }
        elseif ($root_element == 'response') {
            if ($res->error) {
                $this->puts('Error: ' . $res->error->message);
            }
            else {
                // Get elements from the XDebug namespace.
                $xdebug = $res->children('http://xdebug.org/dbgp/xdebug');
                if ($xdebug->message) {
                    // Get the attributes without a namespace.
                    $message = $xdebug->message->attributes('');
                    if ($message['status']) {
                        $this->status = $message['status'];
                    }
                    if ($message['filename']) {
                        $this->current_file = $message['filename'];
                    }
                    if ($message['lineno']) {
                        $this->current_line = $message['lineno'];
                    }
                }
                switch ($res['command']) {
                case 'status':
                    $this->puts('Status: ' . $res['status']);
                    break;
                case 'step_into':
                case 'step_over':
                case 'step_out':
                    // No output, it's kinda obvious.
                    break;
                default:
                    $this->puts('Unknown respomse type "' . $res['command']. '"');
                    $this->puts((string) $res->asXml());
                }
            }
        }
        else {
            $this->puts('Malformed response.');
            $this->puts((string) $res);
            $this->quit(1);
        }

        // Add an empty line.
        $this->puts();
    }

    function quit($code = 0) {
        fclose($this->socket);
        exit($code);
    }

    function puts($string = '') {
        echo $string . "\n";
    }

    function prompt() {
        $prompt = '';
        if ($this->current_file) {
            $prompt = $this->current_file;
        }
        if ($this->current_line) {
            $prompt .= ':' . $this->current_line;
        }
        echo $prompt . "> ";
    }
}

$client = new XDebugClient("tcp://0.0.0.0:9000");
$client->run();
