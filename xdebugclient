#!/usr/bin/php
<?php

class XDebugClient {
    protected $socket;
    protected $transaction_id = 1;
    protected $status = 'starting';
    protected $current_file = '';
    protected $current_line = '';
    protected $socket_buffer = '';

    function __construct($uri) {
        $this->uri = $uri;
    }

    function run() {
        // We'll handle XML errors ourselves, to avoid it spewing
        // warnings all over the place.
        libxml_use_internal_errors(true);
        // @todo error handling.
        $server = stream_socket_server($this->uri, $errno, $errstr);

        $this->puts("Waiting for connection...");
        $this->socket = stream_socket_accept($server);
        // $this->socket->selectRead(60);
        $packet = fread($this->socket, 4096);
        // Strip null byte an verify.
        $res = $this->parseResponse(substr($packet, 0, -1));
        if (!$res) {
            $this->puts('Error parsing init packet, exiting.');
            $this->exit(1);
        }
        if ($res['protocol_version'] != '1.0') {
            $this->puts('Unsupported protocol version.');
            $this->exit(1);
        }
        if ($res->engine) {
            $this->puts('> ' . (string) $res->engine . ' (' . $res->engine['version'] . ')');
        }
        if ($res->url) {
            $this->puts('> ' . (string) $res->url);
        }
        if ($res->author) {
            $this->puts('> by ' . (string) $res->author);
        }
        if ($res->copyright) {
            $this->puts('> ' . (string) $res->copyright);
        }
        if ($res['fileuri']) {
            $this->current_file = $res['fileuri'];
        }
        $this->puts("Connected.");

        // We have no further need for the server socket.
        fclose($server);

        stream_set_blocking(STDIN, 0);

        $exit = false;
        $socket_buffer = '';
        $input_buffer = '';
        do {
            $read = array(STDIN);
            $write = array();
            $except = array();
            // Check if there's already data ready to read.
            $result = stream_select($read, $write, $except, 0);
            if ($result === false) {
                $this->puts("Error using select.");
                $this->quit(1);
            }
            elseif ($result === 0) {
                $this->prompt();
                // Wait until there's something to read.
                $read = array(STDIN);
                $result = stream_select($read, $write, $except, null);
            }

            if (($input = fread(STDIN, 4096)) or $input_buffer) {
                if ($input) {
                    $input_buffer .= $input;
                }
                $t = explode("\n", $input_buffer, 2);
                if (sizeof($t) > 1) {
                    list($cmd, $rest) = $t;
                    $input_buffer = $rest;
                    if (preg_match('/^q(uit)?/', $cmd)) {
                        fwrite($this->socket, 'detach' . "\0");
                        $this->puts("Exiting.");
                        $this->quit();
                    }
                    $this->handleCommand($cmd);
                }
            }
        } while (!$exit);
    }

    function sendCommand($cmd) {
        $txn_id = ($this->transaction_id++);
        // Add in a transaction id.
        $cmd .= ' -i ' . $txn_id;
        fwrite($this->socket, $cmd . "\0");

        $done = FALSE;
        while (!$done) {
            while (preg_match('/^(.*?\0.*?)\0(.*)$/s', $this->socket_buffer, $matches)) {
                $packet = $matches[1];
                $this->socket_buffer = $matches[2];
                $res = $this->parseResponse($packet);
                $result = null;
                if ($res) {
                    if ($res['transaction_id'] and $res['transaction_id'] == $txn_id) {
                        // @todo some handling of resposes with
                        //   another transaction id.
                        $done = true;
                    }
                    if ($this->commonResposeHandling($res)) {
                        // Non-error response.
                        $result = $res;
                    }
                    else {
                        // Errors doesn't have a transaction id, so we
                        // can't tell exactly which command failed. So
                        // we have to assume it was the one we just
                        // sent.
                        $done = true;
                    }
                }
            }
            if (!$done) {
                $this->socket_buffer .= fread($this->socket, 4096);
            }
        }

        return $result;
    }

    function parseResponse($packet) {
        // Every packet starts with a lenght of the following XML data.
        if (!preg_match('/^([0-9]+)\0(.*)$/s', $packet, $matches)) {
            $this->puts("Malformed server packet:");
            $this->puts($packet);
            $this->quit(1);
        }
        // Double safetycheck.
        if (strlen($matches[2]) != $matches[1]) {
            $this->puts("Malformed server packet, wrong length:");
            $this->puts($packet);
            $this->quit(1);
        }
        // No PHP XML parsers seems to like XDebugs <?xml version="1.0"
        // encoding="iso-8859-1"? > header, oddly enough. So we strip it.
        $xml = $matches[2];
        $lines = explode("\n", $matches[2]);
        array_shift($lines);
        $xml = implode("\n", $lines);
        try {
            $res = new SimpleXMLElement($xml);
        }
        catch (Exception $e) {
            $this->puts('Exception: ' . $e->getMessage());
            $res = null;
        }
        if ($errors = libxml_get_errors()) {
            $this->puts('Errors parsing XML response.');
            foreach ($errors as $error) {
                $this->puts(print_r($error, true));
            }
            $this->puts("Raw XML data:");
            $this->puts($xml);
        }
        return $res;
    }

    function handleCommand($cmd) {
        // Empty line, or ones just containing whitespace is
        // interpreted as step_into.
        if (trim($cmd) == "") {
            $cmd = "step_into";
        }
        elseif (preg_match('/^([rsnf])( .*)?$/', $cmd, $matches)) {
            // One character aliases.
            switch ($matches[1]) {
            case 's':
                $cmd = 'step_into';
                break;
            case 'n':
                $cmd = 'step_over';
                break;
            case 'f':
                $cmd = 'step_out';
                break;
            case 'r':
                $cmd = 'run';
                break;
            }
            $cmd = $cmd . (isset($matches[2]) ? $matches[2] : '');
        }

        // Extract command name.
        $parts = explode(' ', $cmd);

        switch ($parts[0]) {
        case 'step_over':
        case 'step_out':
            if ($this->status != 'break') {
                $this->puts($parts[0] . ' only valid in break state.');
                break;
            }
        case 'run':
        case 'step_into':
            if ($this->status != 'break' and $this->status != 'starting') {
                $this->puts($parts[0] . ' only valid in break and starting state.');
                break;
            }
            $res = $this->sendCommand($cmd);
            if (!$res['reason'] == 'ok') {
                $this->puts('Unknown error happended.');
            }
            break;
        case 'status':
            $res = $this->sendCommand($cmd);
            if (!$res['reason'] == 'ok') {
                $this->puts('Unknown error happended.');
            }
            else {
                $this->puts('Status: ' . $res['status']);
            }
            break;
        case 'break':
            $error = false;
            if (sizeof($parts) != 2) {
                $error = true;
            }
            else {
                $file_parts = explode(':', $parts[1]);
                if (sizeof($parts) != 2) {
                    $error = true;
                }
            }
            if ($error) {
                $this->puts("Syntax error.");
                $this->puts("Usage: break <filename>:<linenumber>");
                return null;
            } else {
                $cmd = 'breakpoint_set -t line -f file://' . $file_parts[0] . ' -n ' . $file_parts[1];
                $res = $this->sendCommand($cmd);
                if ($res['id']) {
                    $this->puts('Breakpoint set at line ' . $file_parts[1] . ' in ' . $file_parts[0]);
                }
                else {
                    $this->puts('Unknown error setting breakpoint.');
                }
            }
            break;
        default:
            $this->puts("Unknown command, sending verbatim.");
            $res = $this->sendCommand($cmd);
        case '!':
            array_shift($parts);
            $res = $this->sendCommand(implode(' ', $parts));
            if ($res) {
                $this->puts("XML response:");
                $this->puts((string) $res->asXml());
            }
            break;
        default:
            $this->puts("Unknown command.");
        }
    }

    function commonResposeHandling($res) {
        $root_element = $res->getName();
        $transaction_info = null;
        if ($root_element == 'stream') {
            $this->puts("Got some data. Implement this.");
        }
        elseif ($root_element == 'response') {
            if ($res->error) {
                $this->puts('Error: ' . $res->error->message);
                return false;
            }
            else {
                if ($res['status']) {
                    $this->status = $res['status'];
                }
                // Get elements from the XDebug namespace.
                $xdebug = $res->children('http://xdebug.org/dbgp/xdebug');
                if ($xdebug->message) {
                    // Get the attributes without a namespace.
                    $message = $xdebug->message->attributes('');
                    if ($message['filename']) {
                        $this->current_file = $message['filename'];
                    }
                    if ($message['lineno']) {
                        $this->current_line = $message['lineno'];
                    }
                }
            }
        }
        else {
            $this->puts('Malformed response.');
            $this->puts((string) $res);
        }
        return true;
    }

    function quit($code = 0) {
        fclose($this->socket);
        exit($code);
    }

    function puts($string = '') {
        echo $string . "\n";
    }

    function prompt() {
        $prompt = '';
        if ($this->current_file) {
            $prompt = $this->current_file;
        }
        if ($this->current_line) {
            $prompt .= ':' . $this->current_line;
        }
        echo $prompt . "> ";
    }
}

$client = new XDebugClient("tcp://0.0.0.0:9000");
$client->run();
